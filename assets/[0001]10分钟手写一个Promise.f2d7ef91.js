export default"不要被then需要异步执行吓到了，then传入的是个函数，什么时候调用，应该由第一次回调决定\n静态的all、race等方法，后面再补充\n```\nfunction promise(func){\n\tthis.state = 'pending'; //状态\n\tthis.resolveArg; //回调参数，下同\n\tthis.rejectArg;\n\tthis.thenQueue = []; //调用队列\n\tthis.thenable = true;\n\n\tthis.resolveFunc = _resolveFunc.bind(this);\n\tthis.rejectFunc  = _rejectFunc.bind(this);\n\tthis.catchFunc \t = _catchFunc.bind(this);\n\t//将 res，rej回调传入作用域内并执行主函数\n\ttry {\n\t\tfunc(this.resolveFunc,this.rejectFunc)\n\t} catch (e) {\n\t\tthis.catchFunc(e);\n\t}\n}\npromise.prototype = {\n    constructor : promise,//绑定构造器\n    /* 调用then，只需要把传入的回调压进then队列里即可，不需要timeout操作*/\n\tthen : function(res,rej) {\n\t\tif (!this.thenable) {\n\t\t\treturn this;\n\t\t}\n\t\t//\n\t\tthis.thenQueue.push({\n\t\t\tres : res,\n\t\t\trej : rej\n\t\t})\n\t\treturn this;\n\t},\n\tcatch: function(func) {\n\t\tthis.catchFunc = func;\n\t\treturn this\n\t},\n\tfinally: function (func) {\n\t\tthis.finallyFunc = func;\n\t\tthis.thenable = false;\n\t\treturn this;\n\t}\n}\n/* rej、res回调会将then队列里的函数依次执行，并且上一个then的返回值作为下一个then的参数 */\nfunction _rejectFunc (args) {\n\tthis.rejectArg = args;\n\tthis.state     = 'rejected'\n\tif(!this.thenQueue.length){return;}\n\twhile (this.thenQueue.length) {\n\t\trejCallback = this.thenQueue.shift().rej;\n\t\ttry {\n\t\t\tvar newReturns = rejCallback(this.rejectArg);\n\t\t\tthis.rejectArg = newReturns;\n\t\t} catch (e) {\n\t\t\tthis.catchFunc(e)\n\t\t}\n\t}\n\tthis.finallyFunc && this.finallyFunc();\n\tthis.thenable = false;\n}\n\nfunction _resolveFunc (args) {\n\tthis.resolveArg = args;\n\tthis.state      = 'fullfilled'\n\tif(!this.thenQueue.length){return;}\n\twhile (this.thenQueue.length) {\n\t\tresCallback = this.thenQueue.shift().res;\n\t\ttry {\n\t\t\tvar newReturns  = resCallback(this.resolveArg)\n\t\t\tthis.resolveArg = newReturns;\n\t\t} catch(e) {\n\t\t\tthis.catchFunc(e)\n\t\t}\n\t}\n\tthis.finallyFunc && this.finallyFunc();\n\tthis.thenable = false;\n}\nfunction _catchFunc (e){\n\tthrow Error('Uncaught promise error:' + e)\n}\nnew promise(res=>{\n\tsetTimeout(()=>{\n\t\tres([123])\n\t},1000)\n}).then(res=>{\n\tconsole.log('res',res)\n\treturn 'bbb'\n}).then(res=>{\n\tconsole.log(res)\n})\n\n```\n\n##存在的问题\nPromise.then是在下一个MicroTask调用的，而上述的代码是同步执行\n```\nnew promise(res=>{\n  setTimeout(()=>{\n    res()\n  })\n  console.log('抢先一步')\n}).then()\n```\n设置了setTimeout会使then在MacroTask之后调用\nNode.js中可以使用setImmediate，就能使其真正的在下一个MicroTask执行\n";
