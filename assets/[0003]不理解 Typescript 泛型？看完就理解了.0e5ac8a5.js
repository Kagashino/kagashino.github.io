export default"## 如何理解泛型\n\n泛型(Generic Type)存在于许多编程语言中，许多刚接触Typescript且没有Java、C++等带泛型的语言使用经验的程序员，理解起来会有一定的难度，特此开文扫盲\n\n\n我们再来定义一个盒子box，盒子有number类型的id，而data是任意类型，你可能会想到`any`\n```\ninterface Box {\n  id: number,\n  data: any\n}\n```\n然而`any`一时爽，对后期的阅读和分析大为不利。\n来看看使用泛型的方式，只要在头部使用尖括号`<T>`，代码块中使用T来表示类型即可：\n``` typescript\ninterface Box<T> {\n\tid: number,\n\tdata: T\n}\n```\n使用带有泛型的`Box`的时候，我们再传入具体的值：\n``` typescript\nconst box1: Box<string> = {\n\tid: 1,\n\tdata: 'this is string box'\n}\n\nconst box2: Box<boolean> = {\n\tid: 2,\n\tdata: false\n}\n```\n我们类比一个函数：\n```\nfunction square(a) {\n  return a*a\n}\n```\n上面的泛型`<T>`，类似于`square`函数中的形参`a`， 定义时用来表示**宽泛、不确定**的值（类型），使用的时候再传入具体的值（类型）\n```\nsum(4) // 16\n```\n我们可以将泛型理解为： **参数化的类型**\n有了泛型，我们可以更加具体地描述一个不确定的类型。与`any`相比，泛型更具有约束力。\n\n\n## 泛型的具体用法\n上面提到了`interface`使用泛型的方法，下面将会介绍泛型的其他应用场景\n### 在function/type/class中使用泛型：\n泛型可以在function/type/class中声明。\n还是以`Box`举例，type的泛型长得跟interface的基本一样\n```\ntype Box<B> {\n  id: number,\n  value: B\n}\n```\n\n写一个函数，让一个值变成Box类型：\n```\nfunction toBox<B>(value: B) {\n  return {\n    id: new Date().getTime(),\n    value: value\n  }\n} \n\nconst box3: Box<string> = toBox('string box')\nconst box4: Box<number[]> = toBox([1,2,3,4,5])\n```\n写一个class，把这个Box用class封装起来：\n``` typescript\nclass MyBox<B> {\n  private id: number;\n  private value: B;\n\n  public static from<B> (value: B) {\n    return new MyBox(value)\n  }\n  constructor () {\n      this.id = new Date().getTime();\n      this.value = value;\n  }\n  // 只允许修改成相同类型的value\n  public setValue(value: B): void {\n    this.value = value;\n  }\n\n  public getValue(): B {\n    return this.value;\n  }\n}\n```\n\n### 定义多个泛型\n这次我们定义一个抽屉，抽屉有三层，三层可以放三种数据\n```\ntype Drawer<L1, L2, L3> = [L1, L2, L3];\nconst myDrawer<string, string, string> = ['香烟', '茶叶', '啤酒']\n```\n如果一个React项目使用了TypeScript，那么组件可以接受Props泛型和State泛型\n``` typescript\ntype CountProps = {\n  initValue: number,\n  step?: number\n}\n\ntype CountState = {\n  value: number\n}\nclass Counter extends React.component<CountProps, CountState> {\n  constructor(props) {\n    super(props)\n    this.state = {\n      value: props.initValue || 0\n    } \n  }\n  // 以下略\n}\n```\n### 默认泛型\n如果某个泛型有默认值，使用的时候不传入类型即为默认值：\n```\ntype Box<S = string> {\n  id: number,\n  value: S\n}\n\nvar boxDefault: Box = { id: 6, value: 'default generic' }\nvar boxNumber: Box<number> = { id: 7, value: 3.1416 }\n```\n\n## 原生泛型的应用\n\n#### Array\n这个是最好理解的了，如果想定义一个类型固定的数组除了`type[]`外还可以使用泛型的方式：\n```\nconst bools: Array<boolean> = [true, false, true, true, true]\n\nconst queue = Array<{id: number, value: string }> = [\n  { id: 1, value: 'a' },\n  { id: 2, value: 'b' },\n  { id: 3, value: 'c' },\n]\n```\n与`type[]`相比，如果定义一个带有键值类型的数组，使用Array泛型可读性会更高\n\n#### Set和Map\n```\nconst plants: Set<string> = new Set()\n\nfruits.add('豌豆射手')\nfruits.add('向日葵')\nfruits.add('西瓜投手')\nfruits.add('玉米大炮')\n\nconst subject: Map<string, number> = new Map()\n\nsubject.add('语文', 91)\nsubject.add('数学', 100)\nsubject.add('英语', 92)\nsubject.add('政治', 96)\n```\n\n#### Promise\n```\ntype UserData = {\n  id: number,\n  name: string,\n  age: number\n}\n\nfunction fetchData(): Promise<UserData> {\n  return fetch('/userData').then(res => res.json())\n}\n\nasync function fetchFollowList (): Promise<UserData> {\n  const { id } = await fetchData();\n  return fetch(`/follows/${id}`).then(res => res.json())\n}\n```\n";
