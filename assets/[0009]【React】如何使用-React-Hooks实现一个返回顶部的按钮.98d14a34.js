export default"最近在把玩React Hooks，感觉用起来是真的流畅，不得不说Hooks刷新了我对于封装组件的体验，趁着手热，赶紧写了一个【回到顶部】的组件来试试水\n这篇文章默认各位已经熟悉以下知识点：\n`React`  \n`React Hooks`  \n`Typescript`（用法很简单，不熟悉其实也能看得懂）  \n不了解的请先参阅官方文档；\n\n## 正文\n【回到顶部】是许多网页非常常用的按钮，通常放在长页面的右下角，点击可以直接让页面回到顶端。\n要实现这个组件，需要以下几个要点：\n- 按钮定位设置为`position: fixed;`，并且设置位置到屏幕右下角；\n```scss\n.top-jumper {\n  position: fixed;\n  right: 11%;\n  bottom: 15%;\n  width: 42px;\n  height: 42px;\n  background-color: #fff;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 12px;\n\n  &:before {\n    content: '▲';\n    display: block;\n    text-align: center;\n    color: #aaa;\n    line-height: 42px;\n  }\n  &:hover:before {\n    content: '回顶部';\n  }\n}\n```\n- 编写最基本的组件结构\n```\nimport React from 'react';\nimport './TopJumper.scss'\n\nfunction TopJumper() {\n  return (\n    <div className=\"top-jumper\" onClick={()=>window.scrollTo(0, 0)}>\n      <span className=\"text\"> </span>\n    </div>);\n}\n\nexport default TopJumper;\n```\n- 当然，一般来说如果页面在顶部，按钮是不显示的，我们需要监听滚动事件，等到页面下拉到一定高度再显示，现在我们结合`state hooks`和`effect hooks`控制按钮的显隐：\n```\nimport React, { useEffect, useState } from 'react';\nimport './TopJumper.scss'\n\nfunction TopJumper() {\n  const [show, switchShow] = useState(false); // 设置状态\n\n  useEffect(()=>{\n    const listener = ()=>{\n        switchShow(window.scrollY > 300)\n    } as EventListener;\n    document.addEventListener('scroll', listener);\n    return ()=>document.removeEventListener('scroll', listener); // 组件销毁后，取消监听\n  }, [show] /* 依赖记得给上，否则死循环 */)\n\n  return show ? (\n    <div className=\"top-jumper\" onClick={()=>window.scrollTo(0, 0)}>\n      <span className=\"text\"> </span>\n    </div>) : null;\n}\n\nexport default TopJumper;\n```\n你以为这就完了？非也。但如果你是“又不是不能用”星人，那么下面的内容对你来说已经没用了！  \n作为一个资深切图仔，应该察觉到上面那段代码是不完美的，原因就在于浏览器滚动事件调用得太频繁了，会造成一定的性能问题。\n我们得实现一个节流函数：\n```\n/**\n * create a throttle callback\n * @param callback\n * @param delay\n * @param thisArg\n */\nexport const createThrottle = (\n  callback: Function, \n  delay?: number, \n  thisArg?: unknown\n): Function =>{\n  let lastInvokeTime: number = Date.now();\n  const _delay = Number(delay) || 200\n  return (...args: any[]): void=>{\n    const now = Date.now()\n    if (now - _delay <= lastInvokeTime) {\n      return;\n    }\n    lastInvokeTime = now;\n    callback.call(thisArg, ...args)\n  }\n}\n```\n改造我们的`listener`\n```\nconst listener = createThrottle(()=>{\n  switchShow( window.scrollY > 300 )\n}, 500) as EventListener;\n```\n**最后一步优化：**仔细体会一下shouldShow的逻辑，跟上面的有何不同。\n```\nconst listener = createThrottle(()=>{\n  const shouldShow = window.scrollY > 300;\n  if (shouldShow !== show) {\n    switchShow(shouldShow)\n  }\n}, 500) as EventListener;\n```\n\n这下才是完全体：\n\n```JavaScript\nimport React, {useEffect, useState} from 'react';\nimport {createThrottle} from \"./index\";\nimport './TopJumper.scss'\n\nfunction TopJumper() {\n    const [show, switchShow] = useState(false);\n    useEffect(() => {\n        const listener = createThrottle(() => {\n            const shouldShow = window.scrollY > 300;\n            if (shouldShow !== show) {\n                switchShow(shouldShow)\n            }\n        }, 500)\n        as\n        EventListener;\n        document.addEventListener('scroll', listener);\n        return () => document.removeEventListener('scroll', listener);\n    }, [show])\n\n    return show ? (\n        <div className=\"top-jumper\" onClick={() => window.scrollTo(0, 0)}>\n            <span className=\"text\"></span>\n        </div>) : null;\n}\n\nexport default TopJumper;\n```\n## 写了半天，不给我们看看效果吗？\n您好，有的： [http://www.kgshino.com](http://www.kgshino.com)\n\n**最后的彩蛋**：css中对`html`跟元素添加`scroll-behavior: smooth;`属性，实现网页平滑滚动（不兼容低版本的浏览器）\n```\nhtml {\n  scroll-behavior: smooth;\n}\n```\n";
