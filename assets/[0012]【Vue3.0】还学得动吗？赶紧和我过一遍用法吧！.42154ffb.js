export default"## 写在前面\n**2020.4.20** 更新：目前`Vue3.0` 已经出于 `Beta` 测试阶段，即可以对开发者开放使用了，官方工具链如`vue-router` 、 `vuex` 等仍处于 `Alpha` 阶段，距离正式发布还有一段时间。\n本篇文章发布于**2020.01.14**，如果后续更新/发布的话，会考虑更新这篇文章的内容。\n## 阅读依赖\n本篇文章默认读者已经了解以下知识，没有掌握的请去补课~\n- Vue2.x的用法\n- npm的安装与构建，npx局部安装替代全局安装方法（了解最好，非必须）\n- git相关操作\n- `react hooks`相关知识（了解最好，非必须）\n## Vue3.0介绍\n其他文章已经说得差不多了，几个核心点就是Proxy/函数式API/TS支持以及模板编译优化，不再赘述，想看源码的去github拉代码即可：\n[https://github.com/vuejs/vue-next](https://github.com/vuejs/vue-next)\n## 快速开始\n### 使用 @vue/cli 构建\n需要 vue-cli 版本大于 3.x ，如果是2.x版本，得先升级依赖。\n的这里只介绍全局安装方法：\n```\nnpm i -g @vue/cli\n```\n```\nvue create my-vue3-app\n```\n注意：目前**不建议选择 Typescript 预设**，因为 vuex vue-router 等工具尚未完全支持（当然精力旺盛的可以自己实现）。\n项目初始化完毕，进入 `my-vue3-app` 目录，执行  `vue-next` 安装命令：\n```\nvue add vue-next\n```\n这个命令可以自动运行安装脚本，将你当前 vue 项目升级为 vue 3.0 项目：\n```powershell\n📦  Installing vue-cli-plugin-vue-next...\n\nyarn add v1.22.4\n[1/4] Resolving packages...\n[2/4] Fetching packages...\n\nsuccess Saved 1 new dependency.\ninfo Direct dependencies\n└─ vue-cli-plugin-vue-next@0.1.2\ninfo All dependencies\n└─ vue-cli-plugin-vue-next@0.1.2\nDone in 24.71s.\n✔  Successfully installed plugin: vue-cli-plugin-vue-next\n\n\n🚀  Invoking generator for vue-cli-plugin-vue-next...\n⚓  Running completion hooks...\n\n✔  Successfully invoked generator for plugin: vue-cli-plugin-vue-next\n vue-next  Installed vuex 4.0.\n vue-next  Documentation available at https://github.com/vuejs/vuex/tree/4.0\n vue-next  Installed vue-router 4.0.\n vue-next  Documentation available at https://github.com/vuejs/vue-router-next\n vue-next  Installed @vue/test-utils 2.0.\n vue-next  Documentation available at https://github.com/vuejs/vue-test-utils-next\n```\nhappy coding.\n\n### 从源码构建\n首先把代码拉到本地（默认使用master分支即可），在根目录下执行`npm install && npm run build`， 就能在`/packages/vue/dist`下得到打包后的文件：\n```shell\nvue.cjs.js\nvue.esm-bundler.j s\nvue.esm.prod.js\nvue.global.prod.js\nvue.cjs.prod.js\nvue.esm.js\nvue.global.js\nvue.runtime.esm-bundler.js\n```\n### 浏览器引入使用\n如果在纯浏览器环境下，我们选用上面的`vue.global.js`作为依赖，因为它包含了开发提示以及template编译器。直接来一段小demo：\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Vue3.0 sample</title>\n  \x3c!--  在浏览器下template可以这么写了  --\x3e\n  <script type=\"text/x-template\" id=\"greeting\">\n    <h3>{{ message }}</h3>\n  <\/script>\n  <script src=\"vue.global.js\"><\/script>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\">\n    const { createApp } = Vue;\n    const myApp = {\n      template: '#greeting',\n      data() {\n        return {\n          message: 'Hello Vue3.0'\n        }\n      }\n    }\n    createApp(myApp).mount('#app')\n  <\/script>\n</body>\n</html>\n```\n浏览器中打开，你将看到如下文字：\n> ### Hello Vue3.0\n可以看到：`new Vue`变成了`createApp`，不再接受`option`参数，而是搬到了`mount`方法中。我们的template字符串，现在可以使用`text/x-template`的脚本格式引入，至于其他的用法，**基本**和2.0一模一样\n另外，源码仓库中 [/packages/vue/examples](https://github.com/vuejs/vue-next/tree/master/packages/vue/examples)目录下，提供了几个官方示例，有兴趣的可以去参阅\n\n## 使用webpack构建3.0的sfc\n仔细读读仓库中的`readme.md`，我们发现尤大已经很贴心地为我们做了一个webpack构建项目的最小实践: [https://github.com/vuejs/vue-next-webpack-preview](https://github.com/vuejs/vue-next-webpack-preview)\n同样的操作：拉代码->构建->运行后，看到的是一个点击计数器的基本用法：\n```\n<template>\n  <img src=\"./logo.png\">\n  <h1>Hello Vue 3!</h1>\n  <button @click=\"inc\">Clicked {{ count }} times.</button>\n</template>\n\n<script type=\"text/javascript\">\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const count = ref(0); // 响应式数据\n    // 事件回调不需要任何处理，直接作为对象方法返回即可；\n    const inc = () => {\n      count.value++\n    }\n    return {\n      count,\n      inc\n    }\n  }\n}\n<\/script>\n```\n与2.0不同了，这个`setup`方法就是3.0的新API，定义了一个响应式属性`count`和方法`inc`，将他们作为对象返回，就能在`template`中使用。其中，`ref`是对一个`原始值`添加响应式（装箱），通过`.value`获取和修改（拆箱），对应2.0中的`data`，如果需要对一个对象/数组添加响应式，则需要调用`reactive()`方法\n```\nimport { reactive } from 'vue'\nexport default {\n  setup() {\n    return {\n      foo: reactive({ a: 1, b: 2 })\n    }\n  }\n}\n```\n## 拓展实践\n为了更进一步理解setup，我们改造一下点击计数器——键盘计数器。\n要实现的目标和思路为：\n- 将计数器变成一个组件，由外部控制开启/关闭： `component`、`ref`和`v-if`的使用\n- 计数器监听某个键盘按键，按键名称由父组件作为props传入(如Enter，Space等)： `setup(props)`获取\n- 组件渲染(`onMounted`)后开始监听，组件拆卸（`onUnmounted`）后取消监听：`生命周期钩子`在3.0中的用法\n- 添加`is-odd`文本，表示按键次数是否为奇数：`computed`vue3.0中的用法\n- 按键次数为5的倍数（0除外）时，弹出alert窗口：`watch`在vue3.0中的用法\n\n#### Talk is cheap, show me the code\n首先是改造`App.vue`父组件导入`key-press-enter`子组件，注意看`template`有何变化\n```\n<template>\n    \x3c!--  设置checkbox控制组件开关  --\x3e\n    <input id=\"key-counter\" type=\"checkbox\" v-model=\"enableKeyPressCounter\">\n    <label for=\"key-counter\">check to enable keypress counter</label>\n    <key-press-counter v-if=\"enableKeyPressCounter\" key-name=\"Enter\" />\n</template>\n\n<script type=\"text/javascript\">\n  import { ref } from 'vue'\n  import KeyPressCounter from './KeyPressCounter.vue';\n\n  export default {\n    components: {\n      KeyPressCounter // 组件用法和原来一致\n    },\n    setup() {\n      return {\n        enableKeyPressCounter: ref(false), // 是否开启组件\n      }\n    }\n  }\n<\/script>\n\n```\n可以发现：`template`现在可以像jsx一样作为碎片引入，不需要添加根元素了（当然#app根容器还是需要的）\n接着是子组件`KeyPressCounter.vue`： \n```\n<script>\n <template>\n  <h3>Listening keypress: {{ keyName }}</h3>\n  <p>Press {{ pressCount }} times!</p>\n  <p>Is odd times: {{ isOdd }}</p>\n</template>\n\n<script type=\"text/javascript\">\n  import { onMounted, onUnmounted, ref, effect, computed } from 'vue';\n\n  /**\n   * 创建一个键盘按键监听钩子\n   * @param keyName 按键名称\n   * @param callback 监听回调\n   */\n  const useKeyboardListener = (keyName, callback) => {\n    const listener = (e) =>{\n      console.log(`你按下了${e.key}键`) // 用来验证监听时间是否开启/关闭\n      if (e.key !== keyName) {\n        return;\n      }\n      callback()\n    }\n    // 当组件渲染时监听\n    onMounted(()=>{\n      document.addEventListener('keydown', listener)\n    })\n    // 当组件拆解时监听\n    onUnmounted(()=>{\n      document.removeEventListener('keydown', listener)\n    })\n  }\n\n  export default {\n    name: \"EnterCounter\",\n    /**\n     * @param props 父组件传入的props\n     * @return { Object } 返回的对象可以在template中引用\n     */\n    setup(props) {\n      const { keyName } = props\n      const pressCount = ref(0)\n      // hooks调用\n      useKeyboardListener(keyName, ()=>{\n        pressCount.value += 1;\n      })\n      // watch的用法，可以看到，现在无需声明字段或者source，vue自动追踪依赖\n      effect(()=>{\n        if (pressCount.value && pressCount.value % 5 === 0) {\n          alert(`you have press ${pressCount.value} times!`)\n        }\n      })\n      // computed的用法，基本是原来的配方\n      const isOdd = computed(()=> pressCount.value % 2 === 1)\n\n      return {\n        keyName,\n        pressCount,\n        isOdd\n      }\n    }\n  }\n<\/script>\n```\n以后编写组件就是setup一把梭了！是不是越来越像`react hooks`了?\n对比一下传统写法：\n```\n<template>\n  <div>\n    <h3>Listening keypress: {{ keyName }}</h3>\n    <p>Press {{ pressCount }} times!</p>\n    <p>Is odd times: {{ isOdd }}</p>\n  </div>\n</template>\n\n<script type=\"text/javascript\">\n  let listener\n\n  export default {\n    name: \"EnterCounter\",\n    props: {\n      keyName: String\n    },\n    computed: {\n      isOdd() {\n        return this.pressCount % 2 === 1;\n      }\n    },\n    data() {\n      return {\n        pressCount: 0\n      }\n    },\n    mounted() {\n      listener = (e) =>{\n        if (e.key !== this.keyName) {\n          return;\n        }\n        this.callback()\n      }\n      document.addEventListener('keydown', listener)\n    },\n    beforeUnmount() {\n      document.removeEventListener('keydown', listener)\n    },\n    watch: {\n      pressCount(newVal) {\n        if (newVal && newVal % 5 === 0) {\n          alert(`you have press ${newVal} times!`)\n        }\n      }\n    },\n    methods: {\n      callback() {\n        this.pressCount += 1;\n      }\n    }\n  }\n<\/script>\n\n```\n当然，声明式vs函数式，不能说哪个一定比另外一个好。尤大依然为我们保持了传统api，这也意味着从2.0迁移到3.0，付出的成本是非常平滑的。\n\n## 使用 Vuex hooks\n\n#### 初始化\n首先定义全局的 Store :\n```\nimport { createStore } from 'vuex';\n\nexport default createStore({\n  state: {\n    username: 'Xiaoming',\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n      state: {\n        bar: 'baz',\n      },\n      modules: {\n        nested: {\n          namespaced: true,\n          state: {\n            final: 'you\\'ve done',\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n接着在组件根实例中注入\n```\nimport { createAPP } from 'vue'\nimport Store from './store'\nimport APP from './views/App.vue'\n\ncreateApp(APP)\n  .use(Store) // 以插件安装形式注入\n  .mount('#app')\n```\n#### 如何在setup中引用\n目前 vuex 的辅助函数 `mapState` 、`mapGetter` 、 `mapMutation` 、 `mapAction`，需要绑定组件实例上下文，而 setup 函数中无法访问组件实例，所以这些辅助函数在 setup 中应该用不上了，取而代之的应该是 `useState` 、`useGetter` 、 `useMutation` 、 `useAction` ，目前官方尚未实现。这里**根据 vuex 源码**写一个兼容3.0的 `useState` ，抛砖引玉（代码有点长，可以跳着看）：\n```\nimport { computed } from 'vue';\nimport { useStore } from 'vuex';\n\nconst normalizeNamespace = (fn) => (namespace, map) => {\n  let appliedMap = map;\n  let appliedNamespace = namespace;\n  if (typeof appliedNamespace !== 'string') {\n    appliedMap = namespace;\n    appliedNamespace = '';\n  } else if (namespace.charAt(appliedNamespace.length - 1) !== '/') {\n    appliedNamespace += '/';\n  }\n  return fn(appliedNamespace, appliedMap);\n};\n\nconst normalizeMap = (map) => (Array.isArray(map)\n  ? map.map((item) => ({ key: item, val: item }))\n  : Object.entries(map).map(([key, val]) => ({ key, val })));\n\nexport const useState = normalizeNamespace((namespace, states) => {\n  const res = {};\n  // 将源码中引用的 this.$store 替换成全局store\n  const store = useStore();\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = (computed(() => {\n      let { state, getters } = store;\n      if (namespace) {\n        // eslint-disable-next-line no-underscore-dangle\n        const module = store._modulesNamespaceMap[namespace];\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      // eslint-disable-next-line consistent-return\n      return typeof val === 'function'\n        ? val.call(store, state, getters)\n        : state[val];\n    }));\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n}, true);\n```\n编写完毕，在实际组件中使用：\n```\n<template>\n  <header>\n    <h5>\n      Hello {{ username }} | {{ bar }} | {{ final }}\n    </h5>\n  </header>\n</template>\n\n<script>\nimport { useState } from '../store/hooks';\n\nexport default {\n  name: 'Header',\n  setup() {\n    const { username } = useState(['username']);\n    const { bar } = useState('foo', ['bar']);\n    const { final } = useState('foo/nested', ['final']);\n    return {\n      username,\n      bar,\n      final,\n    };\n  },\n};\n<\/script>\n```\n输出结果：\n> ##### Hello Xiaoming | baz | you've done\n\n## 总结\n- template支持碎片，即除根组件外，子组件无需声明根元素。\n- 传统的组件option api，现在可以用setup来实现，不仅比以前变得更加灵活，在类型分析上（typescript）将会支持得更好\n- 大部分api如ref/reactive/onMounted等方法，现在支持按需导入，对于tree-shaking优化有利\n- setup使开发者不必再关心令人头疼的`this`问题\n- setup是一把双刃剑，如果你的思路足够清晰，那么它将会是你抽象逻辑的利器。反之使用不当同样也会让你的代码变成意大利面条🍝\n- vuex 的辅助函数将在未来以 `useXXXX` 的形式 兼容 setup 函数。\n";
