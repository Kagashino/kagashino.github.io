export default">  When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.\n如果一只鸟走起路来像鸭子，游泳像鸭子，叫起来也像鸭子，那它就可以叫做鸭子 —— James Whitcomb Riley,1849-\n1916\n\n## 免责声明\n本文仅供娱乐参考，其中部分代码具有相当的迷惑性，**不建议**在生产环境中使用\n\n## 什么是鸭子类型\n搜索引擎搜索，可以得出找到如下文字：\n> 在程序设计中，鸭子类型（英语：Duck typing）是动态类型和某些静态语言的一种对象推断风格。在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。支持\"鸭子类型\"的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。\n\n简单来说，判断一个对象是不是 X 类型，只要检查它是否具有 X 的特定属性或者方法，即可把它当中 X 类型的对象。\n在 JavaScript 中存在不少鸭子类型，下面举几个典型例子：\n\n## ArrayLike 类数组对象\n\n\n如果一个 JavaScript Object， 他的元素下标是数字，length 也是数字，如字符串、 `arguments` 等，我们统称这种对象为 **类数组对象 (Array-like Object)**， typing 表示为：\n```\ninterfact ArrayLike<T> {\n\t[key: string | number]?: T,\n\treadonly length: number\n}\n```\n判断方法\n```\nconst isArrayLike = array => array && typeof array.length === 'number'\n```\n\n我们都知道，数组上有 map 、 reduce 等方法，有趣的是：这些方法并不是跟数组严格绑定的。利用 JavaScript 鸭子类型特性，我们可以对数组原型方法以 `call` 、 `apply` 调用，使数组原型方法能处理这些数据：\n```\nconst arrLike = { \n\t'0': 1, \n\t'1': 2, \n\t'2': 3, \n\tlength: 3 \n}\n\n// [].slice === Array.prototype.slice ，下同\n[].slice.call(arrLike) // [1, 2, 3]\n\n[].map.call(arrLike, item => item + 1) // [2, 3, 4]\n\n[].filter.call(arrLike, item => item !== 2) // [1, 3]\n\n[].reduce.call(arrLike, (prev, curr) => prev + curr, 0) // 6\n\n[].map.call('123', Number) // [1, 2, 3]\n```\n\n## Iterable 可迭代对象\n\n如果一个对象或者他的原型上具有 `Symbol.iterator` 方法：\n```\nconst iterable = {\n\t*[Symbol.iterator] () {\n\t\tyield 1;\n\t\tyield 2;\n\t\tyield 3;\n\t}\n};\n\n[...iterable] // [1, 2, 3]\n```\n其中这个函数叫做**迭代器函数**。对象通过调用迭代器函数，就能实现拓展运算符 `...` 拓展或者 `for...of` 迭代，我们称这个对象实现了 [迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)，这个对象为 **可迭代对象**。\n\n在 ES6 中，`Array`, `String`, `arguments`, `Set`, `Map`, `FormData` 等构造函数的原型上都具有自己的 `Symbol.iterator` 迭代器函数。上面的 `arrLike` 可以当作数组处理，但不能被迭代，原因是它没有实现迭代协议，需要对 `arrLike` 添加迭代器函数：\n\n```\narrLike[Symbol.iterator] = function* () {\n\tlet i = 0;\n\twhile (i < this.length) {\n\t\tyield this[i];\n\t\ti++;\n\t}\n}\n\n[...arrLike] // [1, 2, 3]\n```\n\n再比如，有一道面试题，要求你对一个对象使用 for ... of 迭代，其实就是考察你对于迭代协议的理解，你可以把下面的代码甩给面试官：\n```\nconst obj = { a: 1, b: 2, c: 3 };\n/**** 迭代器实现 ****/\nobj[Symbol.iterator] = function* () {\n    for (let key in this) {\n        if (this.hasOwnProperty(key)) {\n                const value = this[key];\n                yield [key, value];\n        }\n    }\n}\n/*******/\nfor (let [key, value] of obj) {\n    console.log(key, value)\n}\n```\n当然，你**可以**使用普通函数实现，函数返回的迭代器对象符合下文的 `Iterator` 类型即可，但是对比上面的代码过于繁琐，不再展示，请移步 [迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n\n可迭代对象 typing 表示：\n```\ninterface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\n```\n\n其中，迭代器 `Iterator` 需要提供 `next`, `return`, `throw` 方法，跟调用生成器函数的返回值相同：\n```\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n```\n\n判断是否为可迭代对象\n```\nconst iterable = data => \n\ttypeof Symbol !== 'undefined' \n\t&& typeof data[Symbol.iterator] === 'function'\n```\n\n## Thenable 对象\n我们调用 `new Promise(()=>{})`时，会返回一个对象，包含 `then`, `catch`, `finally` 等方法。我们把带有 `then` 函数的方法称作 **Thenable 对象**，或者 **类 Promise 对象 (PromiseLike)** 。\n这个对象有什么意义？参考如下代码：\n```\nconst thenable = {\n\tthen(res) {\n\t\tsetTimeout(res, 1000)\n\t}\n}\n\n// 1\nPromise.resolve()\n\t.then(()=>thenable)\n\t.then(()=>console.log('一秒过去'));\n\n// 2\n!async function() {\n\tconst sleep = () => thenable\n\n\tawait sleep();\n\tconsole.log('一秒过去');\n}();\n```\n两段语句都能按照预期执行（等待一秒后打印），证明 Promise 判断一个对象是否需要等待其 `resolved`，仅仅判断它是否有 `then` 函数即可。是不是非常简单粗暴？\n\nThenable tying:\n```\ninterface Thenable<T> {\n    then<T, N = never> (\n    \tresolve: (value: T) => T | Thenable<T> | void,\n    \treject: (reason: any) => N | Thenable<N> | void\n\t): Thenable<T | N>\n}\n```\n\n判断方法：\n```\nconst thenable = fn => fn.then && typeof fn.then === 'function'\n```\n\n## Entries 对象\n\n对于一个对象 `{ a: 1, b: 2, c: 3 }`，使用 `[key, value]` 作为元素的二维数组：\n```\n[\n\t['a', 1],\n\t['b', 2],\n\t['c', 3]\n]\n```\n称为 `Entries` ，Entries 属于上文中的可迭代对象，需要实现可迭代协议，并且不能是原始类型数据（如字符串）\n\n```\ninterface Entries<K,V> {\n\t[key: number]: [K, V],\n\t[Symbol.iterator](): Iterator<T>;\n}\n```\n判断方法：\n```\nconst isEntries = data => {\n\tif (typeof data[Symbol.iterator] !== 'function') {\n    \treturn false;\n\t}\n    return Object.values(data).every(d => Array.isArray(d) && d.length >= 2)\n}\n```\n\n### Object.entries 转化\n\n调用 `Object.entries` 可以将有键值对的对象转化成 Entries\n\n```\nconst entry = Object.entries({ a: 1, b: 2, c: 3 }) // [['a', 1], ['b', 2], ['c', 3]]\n\nconst map = new Map()\nmap.set('a', 1)\nmap.set('b', 2)\nmap.set('c', 3)\n\nObject.entries(map) // [['a', 1], ['b', 2], ['c', 3]]\n\nconst fd = new FormData()\nfd.set('a', 1)\nfd.set('b', 2)\nfd.set('c', 3)\n\nObject.entries(fd) // [['a', 1], ['b', 2], ['c', 3]]\n\nObject.entries('abc') // [['0','a'],['1','b'],['2','c']]\n```\n\n其中，数组、 Map、 Set、 FormData 等引用类型的的原型 `prototype` 上自带 `entries` 方法，调用后返回一个 [**生成器对象**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator) ， 可以使用拓展运算符 `...` 展开：\n```\nconst arrIterator = ['a', 'b', 'c'].entries();\n[...arrIterator] // [['0','a'],['1','b'],['2','c']]\n\nconst setIterator = new Set(['a', 'b', 'c']).entries();\n\n[...setIterator] // [['a', 'a'], ['b', 'b'], ['c', 'c']]\n\nconst map = new Map();\nmap.set('a', 1)\nmap.set('b', 2)\nmap.set('c', 3)\n\nconst mapIterator = map.entries();\n[...mapIterator] // [['a', 1], ['b', 2], ['c', 3]]\n\nconst fd = new FormData();\nfd.set('a', 1)\nfd.set('b', 2)\nfd.set('c', 3)\n\nconst fdIterator = fd.entries(fd);\n[...fdIterator] // [['a', 1], ['b', 2], ['c', 3]]\n```\n注意，因为是生成器对象，一旦迭代完毕，再次调用 `next` 方法或者拓展运算也不会吐出任何 value 了。\n\n### Object.fromEntries 和 Map 构造函数\n\n`Object.fromEntries` 是 ECMAScript 2019 定义的语法（低版本浏览器不兼容），与 `Object.entries` 相反，它将 Entries 对象变为 Object\n\n```\nObject.fromEntries( [['a', 1], ['b', 2], ['c', 3]] ) // { a:1, b:2, c: 3 }\n```\n\n对于 FormData 或者 Map 对象，会隐式转化为 Entries\n```\nconst fd = new FormData()\nfd.set('a', 1)\nfd.set('b', 2)\nfd.set('c', 3)\n\nObject.fromEntries(fd) // [['a', 1], ['b', 2], ['c', 3]]\n\nconst map = new Map()\nmap.set('a', 1)\nmap.set('b', 2)\nmap.set('c', 3)\n\nObject.fromEntries(map) // [['a', 1], ['b', 2], ['c', 3]]\n```\n注意，如果 key 是 number 类型，转化以后 key 会变为 string，如果 Map 对象中有引用类型（即 Object 不接受的 key 类型），则这个键值对会被忽略。\n\n对于数组，因为会在参数类型推导上产生歧义，所以变成 Entries 或者 Entries 生成器对象才能传入\n```\nObject.fromEntries([1,2,3]) // 报错：元素类型不是以 [key, value] 形式存在\n\n// 只有 [['0', 1], ['1', 2], ['2', 3]] 才符合 Entries 性质\nObject.fromEntries([1,2,3].entries()) // [['a', 1], ['b', 2], ['c', 3]]\nObject.fromEntries([...[1,2,3].entries()]) // [['a', 1], ['b', 2], ['c', 3]]\n```\n\n不少人有这个疑惑：既然 Map 是键值对存储，为什么 Map 构造函数不接受 Object 作为参数？\n事实上 Map 构造参数接受的是 Entries 对象，与 `Object.fromEntries` 参数类型相同：\n```\nconst entries = [['a', 1], ['b', 2], ['c', 3]];\n\nnew Map(entries) // Map(3) {\"a\" => 1, \"b\" => 2, \"c\" => 3}\n\nconst fd = new FormData()\nfd.set('a', 1)\nfd.set('b', 2)\nfd.set('c', 3)\n\nnew Map(fd) // Map(3) {\"a\" => 1, \"b\" => 2, \"c\" => 3}\n\nnew Map([1,2,3].entries()) // Map(3) {0 => 1, 1 => 2, 2 => 3}\nnew Map([...[1,2,3].entries()]) // Map(3) {0 => 1, 1 => 2, 2 => 3}\n```\n\n看到这里你就会发现 Entries 其实是 Map 的低配版，Entries 经过 Map 封装，就能优地雅遍历、查询、获取元素数量或者删除等操作。\n\nEntries 起到一个中间人的作用，许多以键值对存在的对象，利用 Entries 可以实现键值对对象之间的相互转化。\n\n## 小结\n- 鸭子类型是根据对象行为推导出来的类型，JavaScript 在处理对象时只会判断其对象行为，并不会真正检查他的确切类型。\n- 判断 ArrayLike，只需检查对象中有 `length` 属性，并且 length 值为数字即可\n- 判断 Iterable，需要检查对象上 `Symbol.iterator` 属性值是否为一个函数\n- 判断 Thenable，需要检查对象上 `then` 属性值是否为一个函数\n- Entries 是以 `[key, value]` 作为元素的二位数组，利用 Entries 的特性，可以使对象 、 Map 、 FormData 等数据结构相互转化。\n";
