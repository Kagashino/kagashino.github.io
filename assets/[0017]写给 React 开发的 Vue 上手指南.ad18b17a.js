export default"# 写给 React 开发的 Vue 上手指南\r\n\r\n## 前言\r\n\r\nVue 和 React 是前端三大流行框架之二，它们在国内有多流行，不必解释。本人呆过不少团队，选择 Vue 的团队对 Vue 的第一印象是：简单、易上手。那么 Vue 是否真的如众多开发者所说的那么简单？能否让一个 React 前端程序猿快速上手？本文会从 React 开发的视角入手，介绍 Vue 的简单使用、特性和对比。\r\n\r\n本文适合以下类型的读者：\r\n\r\n- 被上司逼着换 Vue 框架的 React 程序猿\r\n- 精力旺盛想尝试 Vue 的 React 程序猿\r\n- Vue 、 React 浅度使用，想深入了解其中一项的程序猿\r\n\r\n阅读本文需要掌握以下知识：\r\n\r\n- 理解 this 指向\r\n- 理解 ES6 的 class 、 解构赋值和箭头函数等语法\r\n\r\n另外，如果觉得看文档更加方便，这里提供传送门： https://cn.vuejs.org/index.html\r\n\r\n## Vue 简介\r\n\r\n来看看官网如何定义 Vue：\r\n> 渐进式 JavaScript 框架\r\n\r\n何为渐进式：与开箱即用相反，框架的规模根据你期望的项目规模灵活配置。Vue 本体只提供最基本的数据 - 视图渲染功能，如果想使用模块化开发，可以借助 `@vue/cli` ，如果想引入路由，可以添加 `vue-router`，如果想引入全局状态管理，可以添加 `vuex` ...如果这些还不能满足，还可以引入第三方或者自己编写的插件。**Talk is cheap, show you the code**，下面开始讲解代码：\r\n\r\n## 极简体验\r\n把下面这段代码保存成 `.html` 文件，在浏览器打开就能看到效果（得联网）:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <title>Simple Vue</title>\r\n  <script src=\"https://cdn.jsdelivr.net/npm/vue\"><\/script>\r\n</head>\r\n<body>\r\n  <div id=\"app\"></div>\r\n  <script type=\"text/javascript\">\r\n\r\n    const template = `<h3>{{ message }}</h3>`;\r\n\r\n    new Vue({\r\n        data() {\r\n          return {\r\n            message:; 'Hello Vue!'\r\n          }\r\n        }\r\n    }).$mount('#app')\r\n  <\/script>\r\n</body>\r\n</html>\r\n```\r\n效果大概就是：\r\n> ### Hello Vue!\r\n\r\n这种使用方式，类似于 `jQuery`，只要引入 `vue` 脚本，就能立马开发。\r\n\r\n## 直观对比\r\n\r\n如果需要模块化开发，单单在 html 里写 vue 代码是很吃力的。让我们看看借助脚手架工具创建的单文件组件的写法：\r\n这次简单点，实现一个只有标题和名称的表单：\r\n使用 React 可以这么写：\r\n\r\n```jsx\r\nimport React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default class Cart extends Component {\r\n  // 属性类型检查\r\n  static propTypes = {\r\n    title: PropTypes.string;\r\n  }\r\n  // 组件的状态\r\n  state = {\r\n    name: 'John Smith'\r\n  }\r\n\r\n  onChange = (e) => {\r\n    this.setState({\r\n      name: e.target.value\r\n    })\r\n  }\r\n\r\n  submit = () => {\r\n    alert(`你的名字是: ${state.name}`)\r\n  }\r\n\r\n  // 渲染视图\r\n  render() {\r\n    const {\r\n      props: { title },\r\n      state: { name },\r\n      onChange,\r\n      submit\r\n    } = this;\r\n\r\n    // JSX 模板\r\n    return (\r\n      <div>\r\n        <h3>{title}</h3>\r\n        <input value={name} onChange={onChange} />\r\n        <button onClick={submit}>提交</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n可以，这很 OOP ，接下来看看 Vue 怎么写：\r\n```jsx\r\n<template>\r\n  <div>\r\n    <h3>{{title}}</h3>\r\n    <input v-model=\"name\" />\r\n    <button @click=\"submit\">提交</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  // 声明属性\r\n  props: {\r\n    title: String\r\n  },\r\n  // 声明状态\r\n  data() {\r\n    return {\r\n      name: \"John Smith\"\r\n    }\r\n  },\r\n  // 回调\r\n  methods: {\r\n    settle() {\r\n      alert(`下单成功，总价: ${this.total}`)\r\n    }\r\n  },\r\n}\r\n<\/script>\r\n```\r\n\r\n一板一眼的，看起来非常规律，看起来很像在写 `html`。这里简单介绍一下 Vue 组件的特点：\r\n1. Vue 的组件以单文件形式存在，文件后缀为 `.vue` ，JavaScript 逻辑部分变成了配置式的写法。\r\n2. `template` 以双花括号`{{}}` 作占位符，用以插入表达式\r\n3. 标签属性比 `JSX` 复杂，但实现的功能也比较多。\r\n4. 代表状态的 `data` 属性居然要写成一个函数，原因参考下文。\r\n\r\n## 概念梳理\r\n\r\n### 介绍 Template\r\n\r\n`template` 是 Vue 用来组成 UI 视图的模板语法。有两种使用方式：\r\n- 如果使用脚手架创建的工程化 Vue 项目，可以新建 .vue 文件编写：\r\n```jsx\r\n<template>\r\n  <div class=\"my-div\">\r\n    这是一个 .vue 文件，代表一个组件\r\n  </div>\r\n</template>\r\n<script>\r\n    // JavaScript 逻辑\r\n    export default {}\r\n<\/script>\r\n<style>\r\n    /* 此处可以编写 CSS */\r\n    .my-div {\r\n        width: 300;\r\n        height: 100;\r\n    }\r\n</style>\r\n```\r\nVue 会通过编译工具，把上述代码编译成 JavaScript 代码。\r\n\r\n- 如果在纯 JavaScript 中使用，那么 template 要写成字符串形式：\r\n```javascript\r\nconst MyComp = {\r\n    template: `<div class=\"my-div\">这也是一个 vue 组件</div>`\r\n}\r\n```\r\n\r\n值得一提的是： `template` 不会直接变成 `html` ，而是会变成一个 `render` 函数，拿上文的 MyComp 的 template 举例，编译以后大概会长成这样：\r\n```javascript\r\n{\r\n  render(createElement) {\r\n    return createElement('div', { staticClass: 'my-div'}, '这也是一个 vue 组件')\r\n  }\r\n}\r\n```\r\n下文会对 `render` 函数进行进一步介绍\r\n\r\n#### Template 指令\r\n\r\n指令是 Vue 特殊的属性，借助 Vue 丰富的指令，可以完成很多数据与视图交互功能：\r\n\r\n##### v-bind —— 表达式绑定指令\r\n普通的属性会当作字符串处理，而 `v-bind` 则会解析其中的 JavaScript 表达式\r\n```jsx\r\n<my-comp v-bind:value=\"myValue * 2\" />\r\n```\r\n其中 `myValue` 是你定义的变量可以来自于组件上的 `data` 、 `props` 、`methods` 等。\r\n不过 `v-bind` 太长了，一般会省略掉，可以简写成：\r\n```jsx\r\n<my-comp :value=\"myValue * 2\" />\r\n```\r\n\r\n##### v-on —— 回调绑定指令\r\n跟 `v-bind` 差不多， `v-on` 用来绑定回调：\r\n```jsx\r\n<my-comp v-on:change=\"handleChange\" />\r\n\x3c!-- 可以传入参数，并且不会立即执行 --\x3e\r\n<my-comp v-on:change=\"handleChange(1, 2, 3)\" />\r\n```\r\n简写：\r\n```jsx\r\n<my-comp @change=\"handleChange\" />\r\n```\r\n\r\n##### v-model —— 双向绑定指令\r\n这是一条复合指令，用来对表单元素或者自定义组件的双向绑定，一般在 `input`、 `textarea` 等表单元素中使用：\r\n```jsx\r\n<input v-model=\"inputValue\" />\r\n```\r\n等价于\r\n```jsx\r\n<input :value=\"inputValue\" @input=\"e => inputValue = e.target.value\" type=\"text\" />\r\n```\r\n\r\n\r\n##### v-for —— 循环指令\r\n常用于列表渲染，记得带上 key\r\n```jsx\r\n<li v-for=\"(item, index) in list\" :key=\"item.id\">{{index}} - {{item.name}} </li>\r\n```\r\n除了数组，对字符串、对象同样可以使用，甚至还可以直接写个数字表示循环次数。\r\n```jsx\r\n<span v-for=\"num in 6\">{{num}}</span>\r\n```\r\n\r\n##### v-if/v-else —— 条件渲染指令\r\n顾名思义，通过条件决定元素渲染与否\r\n```jsx\r\n<div v-if=\"scrore >= 100\">你是满分</div>\r\n<div v-else-if=\"scrore >= 60\">你及格了</div>\r\n<div v-else>你挂了</div>\r\n```\r\n注意： v-if 为 false 时 vue 会直接跳过这个节点，如果想要渲染一个样式为 `display: none` 的元素，可以使用 v-show 指令\r\n\r\n```jsx\r\n<div v-show=\"false\">我在 HTML 中，但是 display 为 none</div>\r\n```\r\n\r\n#### 子节点渲染\r\n\r\n如同 JSX 中的 `children` , `template` 中的字节的需要使用 `slot` （插槽）作为占位：\r\n```jsx\r\n<div> this is default <slot></slot> </div>\r\n\x3c!-- 还可以绑定带有命名空间的插槽 --\x3e\r\n<div> this is named <slot name=\"bar\"></slot><div>\r\n```\r\n父节点传入：\r\n```jsx\r\n\x3c!-- this is default child node --\x3e\r\n<Foo>\r\n    <span> child node </span>\r\n</Foo>\r\n\r\n\x3c!-- this is named bar node --\x3e\r\n<Foo>\r\n    <span slot=\"bar\"> bar node </span>\r\n</Foo>\r\n```\r\n\r\n### 如果不用 Template\r\n尽管 `template` 能覆盖绝大部分视图场景，但 `template` 并不是唯一的选择。 Vue 组件 API 中提供了一个 `render` 函数选项，用 JavaScript 的方法直接创建虚拟 DOM：\r\n```javascript\r\nexport default {\r\n    render(createElement) {\r\n        return createElement('h3', null, 'Hello Vue!')\r\n    }\r\n}\r\n```\r\nemmmm... 标签 属性 子节点...有没有似曾相识的感觉？没错，如果 React 不借助 JSX ，也是在 `render` 方法中调用 `createElement` 创建虚拟 DOM ，那么问题来了：能不能使用 JSX 来编写 Vue 组件？\r\n答案是**能**，借助 `@vue/babel-preset-jsx` 这个 babel 插件，就能实现 JSX 编写 Vue 组件视图，详情参考：https://cn.vuejs.org/v2/guide/render-function.html#JSX\r\n\r\n### 一言难尽的 this —— Vue 篇\r\n`this` 真是一个令人又爱又恨的东西，好在 Vue 组件中，绝大部分方法都会把 this 指向当前组件，并且不需要区分 `props` 、`data` （直接 `this.xxx` 一把梭）：\r\n```javascript\r\nexport default {\r\n    props: {\r\n        propA: Number,\r\n        propB: String,\r\n    },\r\n    data() {\r\n        console.log(this.propA); // propA 传入的值\r\n        console.log(this.propB); // propB 传入的值\r\n        return {\r\n            dataA: 'a',\r\n            dataB: 'b',\r\n        }\r\n    },\r\n    methods: {\r\n        getDataA() {\r\n            return this.a;\r\n        },\r\n        getPropA() {\r\n            return this.propA;\r\n        },\r\n        getMethodA() {\r\n            console.log(this.getDataA); // function\r\n            console.log(this.getPropA); // function\r\n        }\r\n    },\r\n    // ....\r\n}\r\n```\r\n注意：**箭头函数的 this 不会如你预期的指向当前组件**，除了 `data` 第一个参数可以访问当前组件，直接把方法写成箭头函数， `this` 会乱飘：\r\n```JavaScript\r\nexport default {\r\n    props: {\r\n        count: Number,\r\n    },\r\n    data: context => ({\r\n        doubleCount: context.count * 2 // work , context 指向当前组件\r\n    }),\r\n    methods: {\r\n        // bad， this 不对\r\n        badTripleCount: () => this.count * 3;\r\n    }\r\n}\r\n```\r\n不过在方法作用域内部使用箭头函数是可以的，这点得区分开来\r\n\r\n```javascript\r\nexport default {\r\n    data() { return { user: '' } }\r\n    methods: {\r\n        // funtion\r\n        getUser() {\r\n            console.log(this.user); // ''\r\n            fetch('/user').then(res => {\r\n                this.user = res;\r\n                console.log(this.user); // res valule\r\n            })\r\n        }\r\n    }\r\n}\r\n```\r\n除了 `data` 、 `methods` 以外， `watch` 、 `computed` 或者部分声明周期钩子回调， this 同样指向当前组件。\r\n如果你不喜欢 `this`， 可以尝试 [Composition API](https://v3.vuejs.org/api/composition-api.html#composition-api)\r\n\r\n### 组件的状态 —— data\r\n\r\n在 React 中，组件的状态放在 state 中，修改状态需要调用 `setState` ，且最好使用新的对象代替：\r\n```javascript\r\nclass Foo extends Component {\r\n  state = {\r\n    list: [\r\n      { id: 1, name: 'foo' },\r\n      { id: 2, name: 'bar' },\r\n      { id: 3, name: 'baz' },\r\n    ]\r\n  }\r\n\r\n  removeItem(id) {\r\n    const { list } = this.state;\r\n    this.setState(list.filter(i => i.id !== id))\r\n  }\r\n}\r\n```\r\n\r\n在 Vue 中，组件的状态叫做 `data` ，但是绝大部分更新都可以由直接对属性赋值完成：\r\n\r\n```javascript\r\nexport default {\r\n  data() {\r\n    return {\r\n      a: 1,\r\n      list: [1,2,3]\r\n    }\r\n  },\r\n  methods: {\r\n    setA(num) {\r\n      this.a = num;\r\n    },\r\n    appendToList(num) {\r\n      this.list.push(num);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n至于实现原理，可以移步下文 **响应式数据**。\r\n\r\n### 单向数据流\r\n\r\n同 React 一样，来自父组件的状态称为 `Props` ，且子组件不要直接修改父组件传入的状态：\r\n\r\n```javascript\r\nexport default {\r\n    props: {\r\n        title: String,\r\n    },\r\n    methods: {\r\n        badSetTitle() {\r\n            // BAD, 不要直接修改\r\n            this.title = '????'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n如果硬要修改，请使用 `Props` 回调：\r\n```javascript\r\nexport default {\r\n  props: {\r\n    value: String,\r\n    onChange: Function\r\n  },\r\n  methods: {\r\n    setValue(value) {\r\n      this.onChange(value);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n父组件通过传入 `onChange` 回调实现修改：\r\n```jsx\r\n<template>\r\n  <MyComp :value=\"myValue\" :onChange=\"handleChange\" />\r\n</template>\r\n<script type=\"text/javascript\">\r\n  export default {\r\n    data() {\r\n      return {\r\n        myValue: ''\r\n      }\r\n    },\r\n    methods: {\r\n      handleChange(value) {\r\n        this.myValue = value\r\n      }\r\n    }\r\n  }\r\n<\/script>\r\n```\r\n\r\n或者使用 Vue 约定的事件更新语法糖：\r\n\r\n```javascript\r\nexport default {\r\n  props: {\r\n    title: String,\r\n  },\r\n  methods: {\r\n    setTitle() {\r\n      this.$emit('update:title', '???')\r\n    }\r\n  }\r\n}\r\n```\r\n然后父组件传入的 `prop` 也要做一次处理：\r\n```jsx\r\n\x3c!-- title 属性追加 .sync 修饰保证 update 事件生效 --\x3e\r\n<MyComponent title.sync=\"title\" />\r\n```\r\n\r\n注意：**这种方法将在 Vue3.0 废弃** 。  \r\n还有一种办法是：把 value 和 onChange 封装成 v-model （抱歉，template 编译就是可以为所欲为）：\r\n\r\n```jsx\r\n<template>\r\n  <input placeholder=\"type something\" value=\"value\" @change=\"e => onChange(e.target.value)\" />\r\n</template>\r\n<script>\r\n  export default {\r\n    model: {\r\n      value: 'value',\r\n      event: 'change'\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n父组件中就可以一条 v-model 搞定：\r\n```jsx\r\n<my-input v-model=\"myValue\" />\r\n\x3c!-- 等价于 --\x3e\r\n<my-input :value=\"myValue\" @change=\"e => myValue = e.target.value\" />\r\n```\r\n\r\n### 生命周期钩子\r\n\r\n组件不是一个持久化的东西，从创建、更新到销毁，每一个 timing 都可以处理一些逻辑，下面列举几个常用的生命周期钩子：\r\n- `beforeCreate` Vue 向组件实例组件挂载 `data` 、 `props` 等状态之前调用\r\n- `created` 组件挂载 `data` 、 `props` 等状态之后调用，可以在此处发起网络请求获取数据\r\n- `mounted` 对应 `componentDidMount` 组件第一次完成 DOM 渲染后的回调，可以在此处发起网络请求获取数据\r\n- `updated` 对应 `componentDidUpdate` 组件更新完毕后调用，由于 Vue 响应式机制，这个方法大部分的场景会被 `watch` 替代。\r\n- `beforeDestroy` 对应 `componentWillUnmount` 组件销毁之前的回调，通常用来清除计时器、某些原生监听事件等操作。\r\n\r\n\r\n其他诸如 `beforeMount` 、 `actived` 、 `destoryed` 等钩子的用法可以参考 https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\r\n\r\n## 特性\r\n讲完了对比，接下来讲 Vue 的一些特性：\r\n\r\n### 响应式数据\r\n\r\n如果你对响应式属性不熟悉，看到赋值也能触发更新，可能会觉得不可思议。事实上 Vue2.x 版本借助了 `Object.defineProperty` 方法，对响应式数据的 `get` 和 `set` 做了一层拦截处理，使得状态在赋值的时候触发了更新回调，从而进行更新操作。\r\n\r\n```javascript\r\nlet valueA = 1;\r\n\r\nlet data = {};\r\n\r\nObject.defineProperty(data, 'a', {\r\n  get() { \r\n    console.log('获取 data.a')\r\n    return valueA \r\n  },\r\n  set(newVal) {\r\n    console.log('更新 data.a')\r\n    valueA = newVal;\r\n  }\r\n\r\n}) // data 此时为 { a: 1 }\r\n\r\ndata.a // 输出 \"获取 data.a\"\r\ndata.a = 100 // 输出 \"更新 data.a\"\r\n```\r\n尽管 `Object.defineProperty` 能让更新更符合直觉，但是这个 API 也有它的局限性：\r\n- 只能检测对象属性的更新，无法检测对象属性的添加和删除，上文如果直接进行 `data.b = 1` 赋值或者 `delete data.a` 删除， set 回调是不会触发的。需要借助 `Vue.set(data, 'b', 1)` 和 `Vue.delete(data, 'a')` 进行显式的添加和删除。\r\n- 对于数组的 `push` 、 `pop` 、 `splice` 等改变原数组的方法，Vue 会隐式重写他们，使得我们直接对数组调用这些方法能够正常被监听。\r\n\r\n在 Vue3.x 中，使用了 `Proxy` API 替代了 `Object.defineProperty` ：\r\n```javascript\r\nconst data = { a: 1 };\r\n\r\nconst proxyData = new Proxy(data, {\r\n  get(obj, key) {\r\n    console.log('获取 data.a')\r\n    return obj[key];\r\n  },\r\n  set(obj, key, value) {\r\n    console.log('更新 data.a')\r\n    obj[key] = value;\r\n  }\r\n})\r\n\r\nconst proxyArray = new Proxy([1, 2, 3], {\r\n  get(obj, key) {\r\n    console.log('获取 array[key]')\r\n    return obj[key];\r\n  },\r\n  set(obj, key, value) {\r\n    console.log('更新 array[key]')\r\n    obj[key] = value;\r\n  }\r\n})\r\n\r\n```\r\n\r\n`Proxy` 能更加优雅地拦截对象的变更，解决了无法对属性增删和拦截数组的问题，而且不需要对每一条属性进行拦截，在一定程度上减少了监听数据的开销。  \r\n相比于 React ， Vue 能更细致地追踪数据的变化，尽可能减少组件更新的粒度。\r\n\r\n#### data 应该是一个函数\r\n看了之前的几段代码你也许注意到一个问题： data 为什么是一个函数？\r\n这是为了避免在创建多个组件时，引用相同的 data 导致多个组件的 data 相互影响：\r\n```JavaScript\r\nconst MyComponent = {\r\n  data: {\r\n    a: 1\r\n  }\r\n}\r\n\r\n// 实例化组件的伪代码\r\nconst initComponent(comp) {\r\n  const compInstance = {};\r\n\r\n  for(const key in comp.data) {\r\n    compInstance[key] = data[key];\r\n  }\r\n\r\n  return compInstance;\r\n}\r\n\r\nconst comp1 = initComponent(MyComponent)\r\nconst comp2 = initComponent(comp1)\r\n\r\ncomp1.a = 2;\r\nconsole.log(comp1.a); // 2\r\nconsole.log(comp2.a); // 2\r\n```\r\n\r\n如何避免上述问题？你可能会想到对组件深拷贝，但是这样会造成不必要的性能浪费，为了优雅地解决这个问题，我们约定： data 应该做成一个返回对象的函数：\r\n```JavaScript\r\nconst MyComponent = {\r\n  data() {\r\n    return {\r\n      a: 1\r\n    }\r\n  }\r\n}\r\n\r\n// 实例化组件的伪代码\r\nconst initComponent(comp) {\r\n  const compInstance = {};\r\n\r\n  for(const key in comp.data()) {\r\n    compInstance[key] = data[key];\r\n  }\r\n\r\n  return compInstance;\r\n}\r\n\r\n// ...\r\n\r\nconsole.log(comp1.a); // 2\r\nconsole.log(comp2.a); // 1\r\n```\r\n\r\n### DOM 的异步更新\r\n同 React 一样， Vue 也会创建虚拟 DOM ，并且通过一系列的 Diff 算法和 Patch，把虚拟 DOM 转变成真实 DOM ，那么 Vue 中真实 DOM 什么时候更新呢？答案是状态变更后，借助 JavaScript 事件循环机制，在下一个微任务进行异步更新：\r\n```jsx\r\n<template>\r\n  <div id=\"msg\">{{ message }}</div>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    message: 'hello world'\r\n  },\r\n  setData() {\r\n    document.getElementById('msg').innerHTML // 'hello world';\r\n\r\n    this.message = 'goodbye world';\r\n    // 此时 DOM 尚未更新\r\n    document.getElementById('msg').innerHTML // 'hello world';\r\n\r\n    // 下一轮微任务的回调， DOM 已然更新\r\n    this.$nextTick(() => {\r\n      document.getElementById('msg').innerHTML // 'goodbye world';\r\n    })\r\n\r\n    // 噢，是个宏任务，已经更新很久了\r\n    setTimeout(() => {\r\n      document.getElementById('msg').innerHTML // 'goodbye world';\r\n    }, 0)\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n## 小结\r\n本文是 [写给 Vue 开发的 React 上手指南](https://juejin.cn/post/6952545904087793678) 的镜像文章，以React 开发者的视角介绍了 Vue 的特性和用法，旨在引导部分 React 转 Vue 的程序猿快速上手 Vue ，避免一些 React 的既定思维对 Vue 开发造成障碍。\r\n\r\n## 问答环节\r\n\r\n### 感觉讲不完啊，还有什么能介绍的？\r\n要想把 Vue 的全貌压缩成一篇几百行的文章是不现实的，本文主要还是以 React 对照为主。如果想深入了解，这里推荐一些常见的用法和配置，带着这些问题翻文档吧：\r\n- Vue 全局配置\r\n- 插件的用法\r\n- 自定义指令\r\n- computed 和 watch\r\n- Provide/Inject 依赖注入\r\n- 组件实例方法(组件 this 上挂载了很多东西)\r\n- 内置组件\r\n\r\n### Vue 有好多相似的 API ，我应该用哪个？\r\n[【Vue.js】 那些相似的 API，我该用哪个？ Vue API 用法大比拼](https://juejin.cn/post/6868262202697056269)\r\n\r\n";
